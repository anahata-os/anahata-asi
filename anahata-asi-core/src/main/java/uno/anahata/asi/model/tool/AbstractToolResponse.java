/* Licensed under the Anahata Software License (ASL) v 108. See the LICENSE file for details. Força Barça! */
package uno.anahata.asi.model.tool;

import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude;
import io.swagger.v3.oas.annotations.media.Schema;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import lombok.Getter;
import lombok.Setter;
import org.apache.commons.lang3.exception.ExceptionUtils;
import uno.anahata.asi.internal.JacksonUtils;
import uno.anahata.asi.internal.TextUtils;
import uno.anahata.asi.internal.TokenizerUtils;
import uno.anahata.asi.model.core.AbstractPart;

/**
 * Represents the response of a tool call, designed for deferred execution.
 * The fields are populated by the {@link #execute()} method.
 * 
 * @author anahata-gemini-pro-2.5
 * @param <C> The specific type of the Call this response is for.
 */
@Getter
@Setter
public abstract class AbstractToolResponse<C extends AbstractToolCall<?, ?>> extends AbstractPart {
    /** The final status of the invocation after execution. */
    @Setter(lombok.AccessLevel.NONE)
    private ToolExecutionStatus status;

    /** The result of the invocation if it succeeded, otherwise {@code null}. */
    private Object result;

    /** A descriptive error message if the tool failed or was rejected. */
    private String error;

    /** The time taken to execute the method, in milliseconds. */
    private long executionTimeMillis;
    
    @Schema(description = "the name of thread that executed this tool")
    private String threadName;
    
    @JsonIgnore
    private transient Thread thread;
    
    /** A list of log messages captured during the tool's execution. */
    private final List<String> logs = new ArrayList<>();
    
    /** A list of attachments (e.g., images, files) generated by the tool. */
    private final List<ToolResponseAttachment> attachments = new ArrayList<>();
    
    /** Optional feedback from the user if the tool execution was prompted. */
    private String userFeedback;

    /** 
     * Map of arguments that were modified by the user before execution. 
     * This is a snapshot of the modifications at the time of execution.
     */
    @JsonInclude(JsonInclude.Include.NON_EMPTY)
    @Schema(description = "these are the modified arguments and values, arguments not contained on this map did not get modified")
    private final Map<String, Object> modifiedArgs = new HashMap<>();

    public AbstractToolResponse(AbstractToolCall<?, ?> call) {
        super(call.getMessage().getToolMessage());
    }
    
    /**
     * Sets the status of the tool execution and fires a property change event.
     * Also updates the token count.
     * 
     * @param status The new status.
     */
    public void setStatus(ToolExecutionStatus status) {
        ToolExecutionStatus oldStatus = this.status;
        this.status = status;
        updateTokenCount();
        getPropertyChangeSupport().firePropertyChange("status", oldStatus, status);
    }
    
    /**
     * Sets the result of the tool execution and updates the token count.
     * @param result The result object.
     */
    public void setResult(Object result) {
        this.result = result;
        updateTokenCount();
    }

    /**
     * Sets the error message and updates the token count.
     * @param error The error message.
     */
    public void setError(String error) {
        this.error = error;
        updateTokenCount();
    }

    /**
     * Updates the estimated token count based on the current state of the response.
     */
    private void updateTokenCount() {
        setTokenCount(TokenizerUtils.countTokens(JacksonUtils.prettyPrint(this)));
    }

    /**
     * Gets the name of the tool that was invoked.
     * @return The tool's name.
     */
    public String getToolName() {
        return getCall().getToolName();
    }
    
    /**
     * Gets the original invocation request that this result corresponds to.
     * @return The originating tool call.
     */
    @JsonIgnore
    public abstract C getCall();
    
    /**
     * Executes the tool logic. This method is responsible for populating
     * the status, result, error, and executionTimeMillis fields.
     */
    public abstract void execute();

    /**
     * Stops the tool execution if it is currently running.
     */
    public abstract void stop();

    /**
     * Rejects the tool call before execution, setting the status to NOT_EXECUTED.
     * @param reason The reason for the rejection.
     */
    public void reject(String reason) {
        setStatus(ToolExecutionStatus.NOT_EXECUTED);
        setError(reason);
    }
    
    /**
     * Sets the running thread and updates the thread name.
     * 
     * @param thread the executing thread.
     */
    public void setThread(Thread thread) {
        if (thread != null) {
            this.threadName = thread.getName();
            getPropertyChangeSupport().firePropertyChange("threadName", null, threadName);
        } else {
            this.threadName = null;
        }
        this.thread = thread;
        getPropertyChangeSupport().firePropertyChange("thread", null, thread);
    }
    
    /**
     * Resets the response to its initial state, clearing results, errors, logs, and attachments.
     */
    public void reset() {
        setStatus(ToolExecutionStatus.NOT_EXECUTED);
        setResult(null);
        setError(null);
        setThread(null);
        setExecutionTimeMillis(0);
        clearLogs();
        this.attachments.clear();
        getPropertyChangeSupport().firePropertyChange("attachments", null, attachments);
    }

    /**
     * Adds a log message to this response, which can be displayed to the user.
     * @param message The log message.
     */
    public void addLog(String message) {
        this.logs.add(message);
        updateTokenCount();
        getPropertyChangeSupport().firePropertyChange("logs", null, logs);
    }
    
    /**
     * Converts a exception to a string and adds it to the error field.
     * 
     * @param t The exception to add.
     */
    public void addError(Throwable t) {
        addError(ExceptionUtils.getStackTrace(t));
    }
    /**
     * Adds a log message to this response, which can be displayed to the user.
     * @param error The error message to add.
     */
    public void addError(String error) {
        if (this.error == null) {
            this.error = error;
        } else {
            this.error = "\n" + error;
        }
        updateTokenCount();
        getPropertyChangeSupport().firePropertyChange("error", null, this.error);
    }
    
    /**
     * Attaches a binary blob to this response.
     * @param data The binary data.
     * @param mimeType The MIME type of the data.
     */
    public void addAttachment(byte[] data, String mimeType) {
        this.attachments.add(new ToolResponseAttachment(data, mimeType));
        updateTokenCount();
        getPropertyChangeSupport().firePropertyChange("attachments", null, attachments);
    }

    /**
     * Removes an attachment from this response.
     * @param attachment The attachment to remove.
     */
    public void removeAttachment(ToolResponseAttachment attachment) {
        if (this.attachments.remove(attachment)) {
            updateTokenCount();
            getPropertyChangeSupport().firePropertyChange("attachments", null, attachments);
        }
    }
    
    /**
     * Gets an unmodifiable view of the attachments.
     * @return The list of attachments.
     */
    public List<ToolResponseAttachment> getAttachments() {
        return Collections.unmodifiableList(attachments);
    }

    /**
     * Clears any log messages captured during execution.
     */
    public void clearLogs() {
        this.logs.clear();
        updateTokenCount();
        getPropertyChangeSupport().firePropertyChange("logs", null, logs);
    }
    
    /**
     * Gets the effective arguments that were used for execution.
     * 
     * @return A map of effective arguments.
     */
    @JsonIgnore
    public Map<String, Object> getEffectiveArgs() {
        Map<String, Object> effective = new HashMap<>(getCall().getArgs());
        effective.putAll(modifiedArgs);
        return effective;
    }

    @Override
    protected int getDefaultTurnsToKeep() {
        return getChatConfig().getDefaultToolTurnsToKeep();
    }
    
    /** {@inheritDoc} */
    @Override
    public void setPruned(Boolean pruned) {
        if (Objects.equals(this.getPruned(), pruned)) {
            return;
        }
        super.setPruned(pruned);
    }

    /** {@inheritDoc} */
    @Override
    public void setTurnsToKeep(Integer turnsToKeep) {
        if (Objects.equals(this.getTurnsToKeep(), turnsToKeep)) {
            return;
        }
        super.setTurnsToKeep(turnsToKeep);
    }

    @Override
    public String asText() {
        return String.format("[%s] %s", status, result != null ? TextUtils.formatValue(result.toString()) : (error != null ? error : ""));
    }
}
