/* Licensed under the Anahata Software License (ASL) v 108. See the LICENSE file for details. Força Barça! */
package uno.anahata.asi.model.tool;

import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import io.swagger.v3.oas.annotations.media.Schema;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import lombok.Getter;
import lombok.Setter;
import org.apache.commons.lang3.exception.ExceptionUtils;
import uno.anahata.asi.chat.Chat;
import uno.anahata.asi.internal.JacksonUtils;
import uno.anahata.asi.internal.TextUtils;
import uno.anahata.asi.internal.TokenizerUtils;
import uno.anahata.asi.model.core.BasicPropertyChangeSource;

/**
 * Represents the response of a tool call, designed for deferred execution.
 * The fields are populated by the {@link #execute()} method.
 * <p>
 * In the V2 architecture, the response is a logical state attribute of the 
 * {@link AbstractToolCall} rather than a top-level message part. It no longer 
 * inherits from AbstractPart and does not participate in history or pruning 
 * directly.
 * </p>
 * 
 * @author anahata-gemini-pro-2.5
 * @param <C> The specific type of the Call this response is for.
 */
@Getter
@Setter
@lombok.extern.slf4j.Slf4j
public abstract class AbstractToolResponse<C extends AbstractToolCall<?, ?>> extends BasicPropertyChangeSource {
    
    /** The originating tool call. */
    @Schema(hidden = true)
    @JsonIgnore
    private final C call;

    /** The final status of the invocation after execution. */
    @Setter(lombok.AccessLevel.NONE)
    @Schema(description = "The execution status of the tool call")
    private ToolExecutionStatus status;

    /** The result of the invocation if it succeeded, otherwise {@code null}. */
    @JsonProperty("result")
    @Schema(description = "The actual return value of the tool method", type = "object", requiredMode = Schema.RequiredMode.REQUIRED)
    private Object result;

    /** A descriptive error message if the tool failed or was rejected. */
    @Schema(description = "Errors logged by the tool during execution")
    private String errors;

    /** The time taken to execute the method, in milliseconds. */
    @Schema(description = "The execution time in milliseconds")
    private long executionTimeMillis;
    
    @Schema(description = "The name of the thread that executed this tool")
    private String threadName;
    
    @Schema(hidden = true)
    @JsonIgnore    
    private transient Thread thread;
    
    /** A list of log messages captured during the tool's execution. */
    @Schema(description = "Log messages generated during tool execution")
    @JsonInclude(JsonInclude.Include.NON_EMPTY)
    private final List<String> logs = new ArrayList<>();
    
    /** A list of attachments (e.g., images, files) generated by the tool. */
    @JsonIgnore
    private final List<ToolResponseAttachment> attachments = new ArrayList<>();
    
    /** Optional feedback from the user if the tool execution was prompted. */
    @Schema(description = "Any comments from the user regarding the tool call")
    private String userFeedback;

    /** 
     * Map of arguments that were modified by the user before execution. 
     * This is a snapshot of the modifications at the time of execution.
     */
    @JsonInclude(JsonInclude.Include.NON_EMPTY)
    @Schema(description = "If the user modified the argument values in the ui prior to execution, these are the modified arguments and values, arguments not contained on this map did not get modified")
    private final Map<String, Object> modifiedArgs = new HashMap<>();

    /**
     * The number of tokens this response consumes in the context window.
     */
    @Schema(hidden = true)
    @JsonIgnore
    private int tokenCount;

    /**
     * Persistent UI state indicating if this response's panel is expanded in the conversation view.
     */
    @Schema(hidden = true)
    @JsonIgnore
    private boolean expanded = true;

    /**
     * Constructs a new AbstractToolResponse.
     * 
     * @param call The originating tool call.
     */
    public AbstractToolResponse(C call) {
        this.call = call;
    }
    
    /**
     * Sets the status of the tool execution and fires a property change event.
     * Also updates the token count.
     * 
     * @param status The new status.
     */
    public void setStatus(ToolExecutionStatus status) {
        ToolExecutionStatus oldStatus = this.status;
        this.status = status;
        updateTokenCount();
        propertyChangeSupport.firePropertyChange("status", oldStatus, status);
        if (getChat() != null) {
            getChat().checkToolPromptCompletion();
            // Critical Fix: Ensure tool execution state is persisted. 
            // This covers manual 'Run' clicks in the UI.
            getChat().autoSave();
        }
    }
    
    /**
     * Sets the result of the tool execution and updates the token count.
     * @param result The result object.
     */
    public void setResult(Object result) {
        this.result = result;
        updateTokenCount();
    }

    /**
     * Sets the error message and updates the token count.
     * @param errors The error message.
     */
    public void setErrors(String errors) {
        this.errors = errors;
        updateTokenCount();
    }

    /**
     * Updates the estimated token count based on the current state of the response.
     */
    private void updateTokenCount() {
        setTokenCount(TokenizerUtils.countTokens(JacksonUtils.prettyPrint(this)));
        // Notify the call that its size has changed.
        if (call != null) {
            call.updateResponseTokenCount();
        }
    }

    /**
     * Gets the name of the tool that was invoked.
     * @return The tool's name.
     */
    public String getToolName() {
        return call.getToolName();
    }
    
    /**
     * Executes the tool logic. This method is responsible for populating
     * the status, result, errors, and executionTimeMillis fields.
     */
    public abstract void execute();

    /**
     * Stops the tool execution if it is currently running.
     */
    public abstract void stop();

    /**
     * Rejects the tool call before execution, setting the status to DECLINED.
     * @param reason The reason for the rejection.
     */
    public void reject(String reason) {
        setStatus(ToolExecutionStatus.DECLINED);
        setErrors(reason);
    }
    
    /**
     * Sets the running thread and updates the thread name.
     * 
     * @param thread the executing thread.
     */
    public void setThread(Thread thread) {
        if (thread != null) {
            this.threadName = thread.getName();
            propertyChangeSupport.firePropertyChange("threadName", null, threadName);
        } else {
            this.threadName = null;
        }
        this.thread = thread;
        propertyChangeSupport.firePropertyChange("thread", null, thread);
    }
    
    /**
     * Resets the response to its initial state, clearing results, errors, logs, and attachments.
     */
    public void reset() {
        setStatus(ToolExecutionStatus.DECLINED);
        setResult(null);
        setErrors(null);
        setThread(null);
        setExecutionTimeMillis(0);
        clearLogs();
        this.attachments.clear();
        propertyChangeSupport.firePropertyChange("attachments", null, attachments);
    }

    /**
     * Adds a log message to this response, which can be displayed to the user.
     * @param message The log message.
     */
    public void addLog(String message) {
        this.logs.add(message);
        updateTokenCount();
        propertyChangeSupport.firePropertyChange("logs", null, logs);
    }
    
    /**
     * Converts a exception to a string and adds it to the errors field.
     * 
     * @param t The exception to add.
     */
    public void addError(Throwable t) {
        addError(ExceptionUtils.getStackTrace(t));
    }
    /**
     * Adds a log message to this response, which can be displayed to the user.
     * @param error The error message to add.
     */
    public void addError(String error) {
        if (this.errors == null) {
            this.errors = error;
        } else {
            this.errors = "\n" + error;
        }
        updateTokenCount();
        propertyChangeSupport.firePropertyChange("errors", null, this.errors);
    }
    
    /**
     * Attaches a binary blob to this response.
     * @param data The binary data.
     * @param mimeType The MIME type of the data.
     */
    public void addAttachment(byte[] data, String mimeType) {
        this.attachments.add(new ToolResponseAttachment(data, mimeType));
        updateTokenCount();
        propertyChangeSupport.firePropertyChange("attachments", null, attachments);
    }

    /**
     * Removes an attachment from this response.
     * @param attachment The attachment to remove.
     */
    public void removeAttachment(ToolResponseAttachment attachment) {
        if (this.attachments.remove(attachment)) {
            updateTokenCount();
            propertyChangeSupport.firePropertyChange("attachments", null, attachments);
        }
    }
    
    /**
     * Gets an unmodifiable view of the attachments.
     * @return The list of attachments.
     */
    public List<ToolResponseAttachment> getAttachments() {
        return Collections.unmodifiableList(attachments);
    }

    /**
     * Clears any log messages captured during execution.
     */
    public void clearLogs() {
        this.logs.clear();
        updateTokenCount();
        propertyChangeSupport.firePropertyChange("logs", null, logs);
    }
    
    /**
     * Gets the effective arguments that were used for execution.
     * 
     * @return A map of effective arguments.
     */
    @JsonIgnore
    public Map<String, Object> getEffectiveArgs() {
        return call.getEffectiveArgs();
    }

    /**
     * Gets the parent chat session.
     * 
     * @return The chat session, or null if not attached.
     */
    @JsonIgnore
    public Chat getChat() {
        return call != null ? call.getChat() : null;
    }

    /**
     * Returns the content of the response as a simple string.
     * 
     * @return The text representation of the response.
     */
    public String asText() {
        return String.format("[%s] %s", status, result != null ? TextUtils.formatValue(result.toString()) : (errors != null ? errors : ""));
    }

    /** {@inheritDoc} */
    @Override
    public void rebind() {
        super.rebind();
        if (status == ToolExecutionStatus.EXECUTING) {
            log.info("Restored tool response in EXECUTING state. Marking as INTERRUPTED (zombie recovery).");
            this.status = ToolExecutionStatus.INTERRUPTED;
        }
    }
}
