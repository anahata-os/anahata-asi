/* Licensed under the Anahata Software License (ASL) v 108. See the LICENSE file for details. Força Barça! */
package uno.anahata.asi.model.tool;

import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import io.swagger.v3.oas.annotations.media.Schema;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.concurrent.atomic.AtomicBoolean;
import lombok.Getter;
import lombok.Setter;
import org.apache.commons.lang3.exception.ExceptionUtils;
import uno.anahata.asi.internal.JacksonUtils;
import uno.anahata.asi.internal.TextUtils;
import uno.anahata.asi.internal.TokenizerUtils;
import uno.anahata.asi.model.core.AbstractPart;

/**
 * Represents the response of a tool call, designed for deferred execution.
 * The fields are populated by the {@link #execute()} method.
 * 
 * @author anahata-gemini-pro-2.5
 * @param <C> The specific type of the Call this response is for.
 */
@Getter
@Setter
@lombok.extern.slf4j.Slf4j
public abstract class AbstractToolResponse<C extends AbstractToolCall<?, ?>> extends AbstractPart {
    /** The final status of the invocation after execution. */
    @Setter(lombok.AccessLevel.NONE)
    @Schema(description = "The execution status of the tool call")
    private ToolExecutionStatus status;

    /** The result of the invocation if it succeeded, otherwise {@code null}. */
    @JsonProperty("result")
    @Schema(description = "The actual return value of the tool method", type = "object", requiredMode = Schema.RequiredMode.REQUIRED)
    private Object result;

    /** A descriptive error message if the tool failed or was rejected. */
    @Schema(description = "Errors logged by the tool during execution")
    private String errors;

    /** The time taken to execute the method, in milliseconds. */
    @Schema(description = "The execution time in milliseconds")
    private long executionTimeMillis;
    
    @Schema(description = "The name of the thread that executed this tool")
    private String threadName;
    
    @JsonIgnore
    private transient Thread thread;
    
    /** A list of log messages captured during the tool's execution. */
    @Schema(description = "Log messages generated during tool execution")
    private final List<String> logs = new ArrayList<>();
    
    /** A list of attachments (e.g., images, files) generated by the tool. */
    @JsonIgnore
    private final List<ToolResponseAttachment> attachments = new ArrayList<>();
    
    /** Optional feedback from the user if the tool execution was prompted. */
    @Schema(description = "Any comments from the user regarding the tool call")
    private String userFeedback;

    /** 
     * Map of arguments that were modified by the user before execution. 
     * This is a snapshot of the modifications at the time of execution.
     */
    @JsonInclude(JsonInclude.Include.NON_EMPTY)
    @Schema(description = "If the user modified the argument values in the ui prior to execution, these are the modified arguments and values, arguments not contained on this map did not get modified")
    private final Map<String, Object> modifiedArgs = new HashMap<>();
    
    /** Recursion guard for synchronized removal. */
    @JsonIgnore
    private transient AtomicBoolean removing = new AtomicBoolean(false);

    public AbstractToolResponse(AbstractToolCall<?, ?> call) {
        super(call.getMessage().getToolMessage());
    }
    
    /**
     * Sets the status of the tool execution and fires a property change event.
     * Also updates the token count.
     * 
     * @param status The new status.
     */
    public void setStatus(ToolExecutionStatus status) {
        ToolExecutionStatus oldStatus = this.status;
        this.status = status;
        updateTokenCount();
        propertyChangeSupport.firePropertyChange("status", oldStatus, status);
    }
    
    /**
     * Sets the result of the tool execution and updates the token count.
     * @param result The result object.
     */
    public void setResult(Object result) {
        this.result = result;
        updateTokenCount();
    }

    /**
     * Sets the error message and updates the token count.
     * @param errors The error message.
     */
    public void setErrors(String errors) {
        this.errors = errors;
        updateTokenCount();
    }

    /**
     * Updates the estimated token count based on the current state of the response.
     */
    private void updateTokenCount() {
        setTokenCount(TokenizerUtils.countTokens(JacksonUtils.prettyPrint(this)));
    }

    /**
     * Gets the name of the tool that was invoked.
     * @return The tool's name.
     */
    public String getToolName() {
        return getCall().getToolName();
    }
    
    /**
     * Gets the original invocation request that this result corresponds to.
     * @return The originating tool call.
     */
    @JsonIgnore
    public abstract C getCall();
    
    /**
     * Executes the tool logic. This method is responsible for populating
     * the status, result, errors, and executionTimeMillis fields.
     */
    public abstract void execute();

    /**
     * Stops the tool execution if it is currently running.
     */
    public abstract void stop();

    /**
     * Rejects the tool call before execution, setting the status to NOT_EXECUTED.
     * @param reason The reason for the rejection.
     */
    public void reject(String reason) {
        setStatus(ToolExecutionStatus.NOT_EXECUTED);
        setErrors(reason);
    }
    
    /**
     * Sets the running thread and updates the thread name.
     * 
     * @param thread the executing thread.
     */
    public void setThread(Thread thread) {
        if (thread != null) {
            this.threadName = thread.getName();
            propertyChangeSupport.firePropertyChange("threadName", null, threadName);
        } else {
            this.threadName = null;
        }
        this.thread = thread;
        propertyChangeSupport.firePropertyChange("thread", null, thread);
    }
    
    /**
     * Resets the response to its initial state, clearing results, errors, logs, and attachments.
     */
    public void reset() {
        setStatus(ToolExecutionStatus.NOT_EXECUTED);
        setResult(null);
        setErrors(null);
        setThread(null);
        setExecutionTimeMillis(0);
        clearLogs();
        this.attachments.clear();
        propertyChangeSupport.firePropertyChange("attachments", null, attachments);
    }

    /**
     * Adds a log message to this response, which can be displayed to the user.
     * @param message The log message.
     */
    public void addLog(String message) {
        this.logs.add(message);
        updateTokenCount();
        propertyChangeSupport.firePropertyChange("logs", null, logs);
    }
    
    /**
     * Converts a exception to a string and adds it to the errors field.
     * 
     * @param t The exception to add.
     */
    public void addError(Throwable t) {
        addError(ExceptionUtils.getStackTrace(t));
    }
    /**
     * Adds a log message to this response, which can be displayed to the user.
     * @param error The error message to add.
     */
    public void addError(String error) {
        if (this.errors == null) {
            this.errors = error;
        } else {
            this.errors = "\n" + error;
        }
        updateTokenCount();
        propertyChangeSupport.firePropertyChange("errors", null, this.errors);
    }
    
    /**
     * Attaches a binary blob to this response.
     * @param data The binary data.
     * @param mimeType The MIME type of the data.
     */
    public void addAttachment(byte[] data, String mimeType) {
        this.attachments.add(new ToolResponseAttachment(data, mimeType));
        updateTokenCount();
        propertyChangeSupport.firePropertyChange("attachments", null, attachments);
    }

    /**
     * Removes an attachment from this response.
     * @param attachment The attachment to remove.
     */
    public void removeAttachment(ToolResponseAttachment attachment) {
        if (this.attachments.remove(attachment)) {
            updateTokenCount();
            propertyChangeSupport.firePropertyChange("attachments", null, attachments);
        }
    }
    
    /**
     * Gets an unmodifiable view of the attachments.
     * @return The list of attachments.
     */
    public List<ToolResponseAttachment> getAttachments() {
        return Collections.unmodifiableList(attachments);
    }

    /**
     * Clears any log messages captured during execution.
     */
    public void clearLogs() {
        this.logs.clear();
        updateTokenCount();
        propertyChangeSupport.firePropertyChange("logs", null, logs);
    }
    
    /**
     * Gets the effective arguments that were used for execution.
     * 
     * @return A map of effective arguments.
     */
    @JsonIgnore
    public Map<String, Object> getEffectiveArgs() {
        Map<String, Object> effective = new HashMap<>(getCall().getArgs());
        effective.putAll(modifiedArgs);
        return effective;
    }

    @Override
    protected int getDefaultMaxDepth() {
        return getCall().getTool().getEffectiveMaxDepth();
    }
    
    /** {@inheritDoc} */
    @Override
    public void setPruned(Boolean pruned) {
        if (Objects.equals(this.getPruned(), pruned)) {
            return;
        }
        Boolean old = this.getPruned();
        super.setPruned(pruned);
        // Bidirectional sync: Fire event for the call as well so UI updates
        getCall().getPropertyChangeSupport().firePropertyChange("pruned", old, pruned);
    }

    /** {@inheritDoc} */
    @Override
    public void setMaxDepth(Integer maxDepth) {
        if (Objects.equals(this.getMaxDepth(), maxDepth)) {
            return;
        }
        Integer old = this.getMaxDepth();
        super.setMaxDepth(maxDepth);
        // Bidirectional sync: Fire event for the call
        getCall().getPropertyChangeSupport().firePropertyChange("maxDepth", old, maxDepth);
    }

    /**
     * {@inheritDoc}
     * Synchronized removal: Removing a tool response automatically removes its call.
     */
    @Override
    public void remove() {
        if (removing.compareAndSet(false, true)) {
            try {
                if (getCall() != null) {
                    getCall().remove();
                }
                super.remove();
            } finally {
                removing.set(false);
            }
        }
    }

    @Override
    protected void appendMetadata(StringBuilder sb) {
        sb.append(" | Status: ").append(status);
    }

    @Override
    public String asText() {
        return String.format("[%s] %s", status, result != null ? TextUtils.formatValue(result.toString()) : (errors != null ? errors : ""));
    }

    /** {@inheritDoc} */
    @Override
    public void rebind() {
        super.rebind();
        this.removing = new AtomicBoolean(false);
        if (status == ToolExecutionStatus.EXECUTING) {
            log.info("Restored tool response in EXECUTING state. Marking as INTERRUPTED (zombie recovery).");
            this.status = ToolExecutionStatus.INTERRUPTED;
        }
    }
}
