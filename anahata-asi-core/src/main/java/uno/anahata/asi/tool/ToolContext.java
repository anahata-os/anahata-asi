/* Licensed under the Anahata Software License (ASL) v 108. See the LICENSE file for details. Força Barça! */
package uno.anahata.asi.tool;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.Map;
import java.util.concurrent.ExecutorService;
import java.util.function.Consumer;
import lombok.Getter;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import uno.anahata.asi.AsiContainer;
import uno.anahata.asi.chat.Chat;
import uno.anahata.asi.internal.TikaUtils;
import uno.anahata.asi.model.tool.java.JavaMethodTool;
import uno.anahata.asi.model.tool.java.JavaMethodToolCall;
import uno.anahata.asi.model.tool.java.JavaMethodToolResponse;
import uno.anahata.asi.model.tool.java.JavaObjectToolkit;
import uno.anahata.asi.resource.ResourceManager;

/**
 * The base class for Java code generated by the AI model or for toolkit
 * implementations. Extending this class provides convenient, thread-local
 * access to the current execution context, including logging, attachments, and
 * the parent chat session.
 *
 * @author anahata-gemini-pro-2.5
 */
@Slf4j
public class ToolContext {

    /**
     * The toolkit instance that owns this context.
     */
    @Getter
    @Setter
    protected JavaObjectToolkit toolkit;

    /**
     * Gets the current tool response from the thread-local context.
     *
     * @return The current response.
     * @throws IllegalStateException if called outside the scope of a tool
     * execution.
     */
    public JavaMethodToolResponse getResponse() {
        JavaMethodToolResponse response = JavaMethodToolResponse.getCurrent();
        if (response == null) {
            throw new IllegalStateException("Cannot access ToolContext outside of a tool execution thread. Capture the context with getToolContext() before entering a subthread.");
        }
        return response;
    }

    /**
     * Returns a thread-safe snapshot of this context. If a tool response is
     * currently active on this thread, it returns a {@link CapturedToolContext}
     * that holds a fixed reference to that response, allowing it to be used in
     * subthreads, the EDT, or classloaders.
     *
     * @return A thread-safe ToolContext instance.
     */
    public ToolContext getToolContext() {
        JavaMethodToolResponse current = JavaMethodToolResponse.getCurrent();
        if (current != null) {
            return new CapturedToolContext(getToolkit(), current);
        }
        return this;
    }

    /**
     * Convenience method to get the current tool call that initiated this
     * execution.
     *
     * @return The current tool call.
     */
    public JavaMethodToolCall getCall() {
        return getResponse().getCall();
    }

    /**
     * Convenience method to get the metadata for the tool currently being
     * executed.
     *
     * @return The current tool metadata.
     */
    public JavaMethodTool getTool() {
        return getCall().getTool();
    }

    /**
     * Convenience method to get the application's global ToolManager.
     *
     * @return The ToolManager instance.
     */
    public ToolManager getToolManager() {
        if (toolkit != null) {
            return toolkit.getToolManager();
        }
        return getResponse().getChat().getToolManager();
    }

    /**
     * Retrieves the singleton instance of a registered toolkit class.
     *
     * @param <T> The type of the toolkit.
     * @param toolkitClass The class of the toolkit to find.
     * @return The toolkit instance.
     * @throws IllegalArgumentException if the toolkit is not found.
     */
    public <T> T getToolkit(Class<T> toolkitClass) {
        return getToolManager().getToolkitInstance(toolkitClass)
                .orElseThrow(() -> {
                    return new IllegalArgumentException("Toolkit not found: " + toolkitClass.getName());
                });
    }

    /**
     * Convenience method to get the parent chat session for the current
     * execution.
     *
     * @return The parent Chat instance.
     */
    public Chat getChat() {
        return getToolManager().getChat();
    }

    /**
     * Convenience method to get the application's ResourceManager.
     *
     * @return The ResourceManager instance.
     */
    public ResourceManager getResourceManager() {
        return getChat().getResourceManager();
    }

    /**
     * Convenience method to get the executor service for the current chat
     * session.
     *
     * @return The session-scoped ExecutorService.
     */
    public ExecutorService getExecutorService() {
        return getChat().getExecutor();
    }

    /**
     * Adds a standard log message to the current tool's response.
     *
     * @param message The log message to add.
     * @throws IllegalStateException if called outside a tool execution thread.
     */
    public void log(String message) {
        getResponse().addLog(message);
    }

    /**
     * Adds an error message to the current tool's response.
     *
     * @param message The error message to add.
     * @throws IllegalStateException if called outside a tool execution thread.
     */
    public void error(String message) {
        getResponse().addError(message);
    }

    /**
     * Attaches a binary blob to the current tool's response.
     *
     * @param data The binary data to attach.
     * @param mimeType The MIME type of the data (e.g., 'image/png').
     */
    public void addAttachment(byte[] data, String mimeType) {
        getResponse().addAttachment(data, mimeType);
    }

    /**
     * Convenience method to attach a file to the current tool's response. The
     * MIME type is detected automatically using Tika.
     *
     * @param file The file to attach.
     * @throws IOException if the file cannot be read or the MIME type detection
     * fails.
     */
    public void addAttachment(File file) throws IOException {
        addAttachment(file.toPath());
    }

    /**
     * Convenience method to attach a file from a Path to the current tool's
     * response. The MIME type is detected automatically using Tika.
     *
     * @param path The path to the file to attach.
     * @throws IOException if the file cannot be read or the MIME type detection
     * fails.
     */
    public void addAttachment(Path path) throws IOException {
        byte[] data = Files.readAllBytes(path);
        String mimeType;
        try {
            mimeType = TikaUtils.detectMimeType(path.toFile());
        } catch (Exception e) {
            throw new IOException("Failed to detect MIME type for " + path, e);
        }
        addAttachment(data, mimeType);
    }

    /**
     * Gets a shared map for storing state across turns within the current chat
     * session.
     *
     * @return The session-scoped attributes map.
     */
    public Map getSessionMap() {
        return getToolManager().getSessionAttributes();
    }

    /**
     * Gets a map for sharing objects across all sessions within the current ASI
     * container.
     *
     * @return The container-scoped attributes map.
     */
    public Map getContainerMap() {
        return getChat().getConfig().getContainer().getContainerAttributes();
    }

    /**
     * Gets a static, application-scoped map for sharing objects across all
     * containers in the current JVM.
     *
     * @return The application-scoped attributes map.
     */
    public Map getApplicationMap() {
        return AsiContainer.applicationAttributes;
    }

    /**
     * Executes a task asynchronously in the session's executor service,
     * automatically propagating the current tool execution context to the
     * background thread.
     *
     * @param taskName A descriptive name for the task (used for thread naming).
     * @param task The task to execute.
     */
    public void runAsync(String taskName, Runnable task) {
        final JavaMethodToolResponse response = getResponse();
        getExecutorService().submit(() -> {
            String oldName = Thread.currentThread().getName();
            Thread.currentThread().setName(oldName + " [" + taskName + "]");
            JavaMethodToolResponse.setCurrent(response);
            try {
                task.run();
            } catch (Throwable t) {
                log.error("Async tool task '{}' failed", taskName, t);
                try {
                    response.addError("Async task '" + taskName + "' failed: " + t.getMessage());
                } catch (Exception e) {
                    log.error("Failed to report async error to tool response", e);
                }
            } finally {
                JavaMethodToolResponse.setCurrent(null);
                Thread.currentThread().setName(oldName);
            }
        });
    }

    /**
     * Gets a thread-safe logging consumer that automatically propagates the
     * current tool execution context whenever a message is logged.
     *
     * @return A context-aware logging consumer.
     */
    public Consumer<String> getThreadSafeLogger() {
        final JavaMethodToolResponse response = getResponse();
        return (msg) -> {
            JavaMethodToolResponse.setCurrent(response);
            try {
                log(msg);
            } finally {
                JavaMethodToolResponse.setCurrent(null);
            }
        };
    }

    /**
     * A thread-safe, immutable snapshot of a tool's execution context. Unlike
     * the standard ToolContext, which relies on a ThreadLocal to find the
     * active response, this implementation holds a fixed reference.
     */
    private static class CapturedToolContext extends ToolContext {

        private final JavaMethodToolResponse capturedResponse;

        private CapturedToolContext(JavaObjectToolkit toolkit, JavaMethodToolResponse response) {
            this.toolkit = toolkit;
            this.capturedResponse = response;
        }

        @Override
        public JavaMethodToolResponse getResponse() {
            // Bypass ThreadLocal! Use the captured reference directly.
            return capturedResponse;
        }

        @Override
        public ToolContext getToolContext() {
            return this; // Already captured
        }
    }

}
