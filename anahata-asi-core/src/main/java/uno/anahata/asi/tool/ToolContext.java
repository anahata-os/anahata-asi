/* Licensed under the Anahata Software License (ASL) v 108. See the LICENSE file for details. Força Barça! */
package uno.anahata.asi.tool;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.Map;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutorService;
import lombok.Getter;
import lombok.Setter;
import uno.anahata.asi.AsiContainer;
import uno.anahata.asi.chat.Chat;
import uno.anahata.asi.internal.TikaUtils;
import uno.anahata.asi.model.tool.AbstractToolkit;
import uno.anahata.asi.model.tool.java.JavaMethodTool;
import uno.anahata.asi.model.tool.java.JavaMethodToolCall;
import uno.anahata.asi.model.tool.java.JavaMethodToolResponse;
import uno.anahata.asi.model.tool.java.JavaObjectToolkit;
import uno.anahata.asi.resource.ResourceManager;

/**
 * The base class for Java code generated by the AI model or for toolkit implementations.
 * Extending this class provides convenient, thread-local access to the current 
 * execution context, including logging, attachments, and the parent chat session.
 * 
 * @author anahata-gemini-pro-2.5
 */
public class ToolContext {
    
    /** The toolkit instance that owns this context. */
    @Getter
    @Setter
    protected JavaObjectToolkit toolkit;
    
    /**
     * Gets the current tool response from the thread-local context.
     *
     * @return The current response.
     * @throws IllegalStateException if called outside the scope of a tool execution.
     */
    public JavaMethodToolResponse getResponse() {
        JavaMethodToolResponse response = JavaMethodToolResponse.getCurrent();
        if (response == null) {
            throw new IllegalStateException("Cannot access ToolContext outside of a tool execution thread.");
        }
        return response;
    }

    /**
     * Convenience method to get the current tool call that initiated this execution.
     * 
     * @return The current tool call.
     */
    public JavaMethodToolCall getCall() {
        return getResponse().getCall();
    }

    /**
     * Convenience method to get the metadata for the tool currently being executed.
     * 
     * @return The current tool metadata.
     */
    public JavaMethodTool getTool() {
        return getCall().getTool();
    }

    /**
     * Convenience method to get the application's global ToolManager.
     * 
     * @return The ToolManager instance.
     */
    public ToolManager getToolManager() {
        return toolkit.getToolManager();
    }
    
    /**
     * Convenience method to get the parent chat session for the current execution.
     * 
     * @return The parent Chat instance.
     */
    public Chat getChat() {
        return getToolManager().getChat();
    }
    
    /**
     * Convenience method to get the application's ResourceManager.
     * 
     * @return The ResourceManager instance.
     */
    public ResourceManager getResourceManager() {
        return getChat().getResourceManager();
    }
    
    /**
     * Convenience method to get the executor service for the current chat session.
     * 
     * @return The session-scoped ExecutorService.
     */
    public ExecutorService getExecutorService() {
        return getChat().getExecutor();
    }

    /**
     * Adds a standard log message to the current tool's response.
     * 
     * @param message The log message to add.
     */
    public void log(String message) {
        getResponse().addLog(message);
    }
    
    /**
     * Adds an error message to the current tool's response.
     * 
     * @param message The error message to add.
     */
    public void error(String message) {
        getResponse().addError(message);
    }

    /**
     * Attaches a binary blob to the current tool's response.
     * 
     * @param data The binary data to attach.
     * @param mimeType The MIME type of the data (e.g., 'image/png').
     */
    public void addAttachment(byte[] data, String mimeType) {
        getResponse().addAttachment(data, mimeType);
    }
    
    /**
     * Convenience method to attach a file to the current tool's response.
     * The MIME type is detected automatically using Tika.
     * 
     * @param file The file to attach.
     * @throws IOException if the file cannot be read or the MIME type detection fails.
     */
    public void addAttachment(File file) throws IOException {
        addAttachment(file.toPath());
    }
    
    /**
     * Convenience method to attach a file from a Path to the current tool's response.
     * The MIME type is detected automatically using Tika.
     * 
     * @param path The path to the file to attach.
     * @throws IOException if the file cannot be read or the MIME type detection fails.
     */
    public void addAttachment(Path path) throws IOException {
        byte[] data = Files.readAllBytes(path);
        String mimeType;
        try {
            mimeType = TikaUtils.detectMimeType(path.toFile());
        } catch (Exception e) {
            throw new IOException("Failed to detect MIME type for " + path, e);
        }
        addAttachment(data, mimeType);
    }
    
    /**
     * Gets a shared map for storing state across turns within the current chat session.
     * 
     * @return The session-scoped attributes map.
     */
    public Map getSessionMap() {
        return getToolManager().getSessionAttributes();
    }
    
    /**
     * Gets a map for sharing objects across all sessions within the current ASI container.
     * 
     * @return The container-scoped attributes map.
     */
    public Map getContainerMap() {
        return getChat().getConfig().getContainer().getContainerAttributes();
    }
    
    /**
     * Gets a static, application-scoped map for sharing objects across all containers 
     * in the current JVM.
     * 
     * @return The application-scoped attributes map.
     */
    public Map getApplicationMap() {
        return AsiContainer.applicationAttributes;
    }

}
